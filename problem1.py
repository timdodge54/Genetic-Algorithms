import copy
import typing
import numpy as np


def func(x_1: float, x_2: float) -> float:
    """Evaluate the objective function."""
    return 100 * (x_2 - x_1**2) ** 2 + (1 - x_1) ** 2


def evaluate_generation_fit(generation: typing.List[typing.Tuple[float, float]]):
    # variable that stores all fitness values for a generation
    fitness_of_generation = []
    for citizen in generation:
        # evaluate the fitness and store
        fitness_ = func(citizen[0], citizen[1])
        fitness_of_generation.append(fitness_)
    # sort generation by fitness
    generation_sorted = [x for _, x in sorted(zip(fitness_of_generation, generation))]
    mid = int(len(generation_sorted) / 2)
    # slice save only the most fit
    preserved_citizens = generation_sorted[:mid]
    # copy reserved citizens
    new_generation = copy.deepcopy(preserved_citizens)
    # saving first and last citizen to add one more child at the end to keep
    # list at 50
    first_cit = new_generation[0]
    last_cit = new_generation[-1]
    # crossover preserved citizens
    for i in range(0, len(preserved_citizens) - 1, 2):
        child_1, child_2 = crossover(preserved_citizens[i], preserved_citizens[i + 1])
        new_generation.append(child_1)
        new_generation.append(child_2)
    # mutate
    child_1, child_2 = crossover(first_cit, last_cit)
    new_generation.append(child_1)

    mut_generation = mutate(new_generation)
    return mut_generation


def crossover(
    sol_set_0: typing.Tuple[float, float], sol_set_1: typing.Tuple[float, float]
) -> typing.Tuple[typing.Tuple[float, float], typing.Tuple[float, float]]:
    """Swap the second indecies of the two generation citezins."""
    first_new_child = (sol_set_0[0], sol_set_1[1])
    second_new_child = (sol_set_1[0], sol_set_0[1])
    return first_new_child, second_new_child


def mutate(population: typing.List[typing.Tuple[float, float]]):
    # set probobility of mutation
    prob_mut = 0.05
    mut_population = []
    for citizen in population:
        # if current citizen is mutated
        if np.random.rand(1) > prob_mut:
            # randomly choose index to mutate
            index = np.random.randint(0, 1)
            done = False
            while not done:
                # mutate it by an amount random generated by normal distribution
                # with standard dev of .1 and center at .1
                mutation_amount = 0.1 * np.random.randn(1, 1)
                new_value = citizen[index] + mutation_amount
                # if new value does not violates constraints
                if new_value > 0 and new_value < 5:
                    done = True
            if index == 0:
                mut_population.append((float(new_value), citizen[1]))
            else:
                mut_population.append((citizen[0], float(new_value)))
        else:
            mut_population.append(citizen)
    return mut_population


def evaluate_final_val(
    generation: typing.List[typing.Tuple[float, float]]
) -> typing.Tuple[float, float, float]:
    """Evaluate the most fit value from the final generation."""
    fitness_of_generation = []
    for citizen in generation:
        fitness_ = func(citizen[0], citizen[1])
        fitness_of_generation.append(fitness_)
    generation_sorted = [x for _, x in sorted(zip(fitness_of_generation, generation))]
    final_x_1, final_x_2 = generation_sorted[0]
    return (final_x_1, final_x_2, func(final_x_1, final_x_2))


def _main():
    original_population: typing.Tuple[float, float] = []
    GENERATION_SIZE = 50
    for i in range(GENERATION_SIZE):
        cell_vars = 5 * np.random.random_sample(2)
        cell = (float(cell_vars[0]), float(cell_vars[1]))
        original_population.append(cell)
    count = 0
    population = original_population
    while count < 100000:
        population = evaluate_generation_fit(population)
        count += 1
    final = evaluate_final_val(population)
    print(f"x_1 = {final[0]}, x_2 = {final[1]}, f = {final[2]}")


if __name__ == "__main__":
    _main()
